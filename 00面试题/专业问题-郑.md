# 资料

### 1、闭包

> **MDN定义:**一个函数和对其周围状态的引用捆绑在一起的组合就叫 **闭包**

> **作用:**闭包可以在一个内层函数中访问到其外层函数的作用域。

eg:

```javascript
function init() {
    var name = "Mozilla"; // name 是一个被 init 创建的局部变量
    function displayName() { // displayName() 是内部函数，一个闭包
        alert(name); // 使用了父函数中声明的变量
    }
    displayName();
}
init();
```

例子中的displayName()函数中并没有定义name变量，但是执行displayName()却可以拿到其外层作用域中的局部变量name，**这个组合就叫闭包。**

> 更多参考MDN:[闭包 - JavaScript | MDN (mozilla.org)](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures)



### 2、箭头函数

> **箭头函数表达式**的语法比[函数表达式](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/function)更简洁，并且没有自己的`this`，`arguments`，`super`或`new.target`。

> 箭头函数的this:  **从自己作用域链的上一层继承this**
>
> 普通函数this指向  **调用者**

eg:

```javascript
let v=new Vue({
  router,
  store,
  render: (h) => h(App),
  methods:{
    say:function(){
      console.log('i am vue say',this);
    },
    say2:()=>{
      console.log('i am vue say2',this);
    }
  },
  mounted() {
    // 加载事件 取route 删除sessionStorage
  },
}).$mount("#app");

v.say() //普通函数，this指向调用者， 即vue
v.say2() //箭头函数，从自己作用域上一层继承this，即window


let person={
  name:'zs',
  say:function(){
    console.log('i am zs',this);
  },
  say2:()=>{
    console.log('i am ls',this);
  }
}

person.say() //普通函数，this指向调用者， 即person
person.say2() //箭头函数，从自己作用域上一层继承this， 即window
```



### 3、变量假死

> let在函数定义域中，不提升

eg:

```
var num=2;

function f(){
	console.log(num);		//Cannot access 'num' before initialization
	let num=5;		//let在{}定义域中，不提升
}

f();
```



### 4、apply() 、call() 、bind()区别

> call()、apply() : 改变其this指向的同时，也执行函数
>
> bind()) : 改变其this指向的同时，**不**执行函数



> **参数不同:**
>
> apply(obj, [参数1， 参数2， 参数3])
>
> call(obj, 参数1， 参数2， 参数3) 
>
>  bind(obj,参数1，参数2，参数3)

eg:

```
f.apply(); //参数为null 则 this指向window
f.apply(obj); //参数为obj 则 this指向对象obj

f.bind(null);		//函数this 指向 window
f.bind(p);		//函数this 指向 对象p
```



### 5、判断类型三种方法

> typeof
>
> instanceof
>
> Object.prototype.toString.call

```
console.log(typeof true); //'boolean'

console.log(new String('zlm') instanceof String); //true，s对象在String这个原型链上
console.log('3A' instanceof String); //false，这个是基本数据类型不是function

console.log(Object.prototype.toString.call('zlm')); //'[object String]'
```



### 6、盒子模型

> 盒子模型封装周围的 HTML 元素，包括:margin，border，padding和实际内容。

（1）有两种， IE 盒子模型(体庞)、W3C 盒子模型（标准盒子，掏空）； 

（2）盒模型: 内容(content)、填充(padding)、边界(margin)、 边框(border)；

（3）区  别: IE的 width = border + padding + content



### 7、预解析

> **定义:**浏览器在执行页面代码之前，会先把页面代码都扫描一遍，并把 声明式的函数和变量 都提到所在作用域的最前端

如:

**全局变量提升:**在预解析阶段，浏览器的JS引擎，会将 变量 的声明部分，都提到所在作用域的 最前端

**局部变量提升:**在函数内部 ，局部变量在预解析时，会把 变量 的声明部分 ，提升到当前函数内部的最前端

**函数提升:**只有**声明式函数**才有函数提升,**匿名方式**和**对象方式**创建的函数,在预解析时不会做函数提升

声明式函数 eg:

```
var sum=0;
function Person() {
	var a=1;
}
```



### 8、Cookie和Session区别

> **Cookie**
>
> 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。
>
> **Session**
>
> 当用户在应用程序的 Web 页之间跳转时，存储在 Session 对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。当客户端关闭会话，或者 Session 超时失效时会话结束。



> **作用范围:**Cookie 保存在客户端，Session 保存在服务器端
>
> **存取方式:**Cookie 只能保存 ASCII，Session 可以存任意数据类型
>
> **有效期:**Cookie 可设置为长时间保持，比如我们经常使用的默认登录功能，Session 一般失效时间较短，客户端关闭或者 Session 超时都会失效。
>
> **存储大小:** 单个 Cookie 保存的数据不能超过 **4K**，Session 可存储数据远高于 Cookie。



> **关联:**Cookie 一般用来记录此 SessionID 属于哪个域名，以此判断登录是否失效



> **若禁止Cookie，如何判断登录是否失效?**
>
> 当用户第一次登录后，服务器根据提交的用户信息生成一个 Token，响应时将 Token 返回给客户端，以后客户端只需带上这个 Token 前来请求数据即可，无需再次登录验证。



### 9、解决跨域请求

> 浏览器的同源策略:**“协议+域名+端口”** 有一个不相同即不同源，浏览器禁止请求



> **Jsonp解决方法:**
>
> 浏览器的同源策略把跨域请求都禁止了，但是页面中的 `<script><img><iframe>`标签例外，不受同源策略限制。Jsonp 就是利用 `<script>` 标签跨域特性进行跨域数据访问。
>
> **具体实现:**
>
> 与服务端约定好一个回调函数名，服务端接收到请求后，将返回一段 Javascript，在这段 Javascript 代码中调用了约定好的回调函数，并且将数据作为参数进行传递。当网页接收到这段 Javascript 代码后，就会执行这个回调函数，这时数据已经成功传输到客户端了。

> 前端配置代理：
>
> 在vue-cli的vue.config.js中配置代理地址



### 10、伪类和伪元素

> **伪类:**  为了弥补Css选择器的不足，**存在**于DOM树中。如:hover
>
> **伪元素:**创建的虚拟元素，**不存在**DOM树中。如 ::before

**伪类编写顺序（L V H A）** :  a:link {} a:visited {} a:hover {} a:active {}



### 11、Get和Post区别

> **TCP数据包:** 
>
> **Get请求:** 1个TCP数据包。浏览器会把Http Header和Data一起发送出去，服务器响应200（请求成功）
>
> **Post请求:** 2个TCP数据包（Firefox发送1个）。浏览器先发送Http Header，服务器响应100（继续），浏览器再发送Data 服务器响应200（请求成功）



> **用法:**
>
> Get请求:一般用来获取数据 
>
> Post请求:一般用来发送数据 



> **参数:**
>
> Get请求:参数在地址栏可见，参数长度受不同浏览器对URL的限制
>
> Post请求:参数放在request body中，无长度限制



> **刷新回退浏览器:**
>
> Get请求:无影响（会从缓存中拿数据）
>
> Post请求:回退会重新提交请求



> **缓存:**
>
> Get请求:请求**可**被缓存，**可**保留在历史记录，**可**收藏为书签
>
> Post请求:请求**不可**被缓存，**不可**保留在历史记录，**不可**收藏为书签



> **编码方式:**
>
> Get请求:只能进行url编码（application/x-www-form-urlencoded）
>
> Post请求:支持多种编码方式（application/x-www-form-urlencoded 或 multipart/form-data）



### 12、Set和Map

> **Set:**  结构类似数组  值唯一
>
> **Map:** 结构类似对象 键值对  key唯一

eg:

```javascript
const set = new Set([1, 2, 3, 3, 3]);
console.log(set, set.size); //Set类型:[1,2,3]  3
```

```javascript
let map = new Map([
		['a', 123],
		['b', 456],
		['b', 456]
]);
console.log(map); //0:{'a'=>123} 1:{'b'=>456}
```



### 13、Vue全家桶

> **定义:Vue.js** 是一套用于构建用户界面的 **渐进式框架**

> **定义:Vue Router** 是 Vue.js官方的 **路由管理器**

> **定义:Vue CLI** 快速构建项目的**脚手架**

> **定义:Vuex** 是一个专为 Vue.js 应用程序开发的 **状态管理模式**

> **定义:Axios** 是一个基于 promise 的 **HTTP 库**



### 14、Promise

> **定义:** Promise对象用于表示一个异步操作的最终完成 (或失败)及其结果值

Promise把异步操作最终的成功返回值或者失败原因和相应的处理程序关联起来。 这样使得异步方法可以像同步方法那样返回值:异步方法并不会立即返回最终的值，而是会返回一个 *promise*，以便在未来某个时候把值交给使用者。

```
promise构造函数是同步执行，then方法是异步执行
微任务（入队的Promise回调）的优先级高于宏任务（入队的setTimeout()回调）
```

```javascript
      setTimeout(() => {
        console.log("4");
        setTimeout(() => {
          console.log("8");
        }, 0);
        new Promise((r) => {
          console.log("5");//构造函数是同步的
          r();
        }).then(() => {
          console.log("7");//then()是异步的，这里已经入队
        });
        console.log("6");
      }, 0);

      new Promise((r) => {
        console.log("1");//构造函数是同步的
        r();
      }).then(() => {
        console.log("3");//then()是异步的，这里已经入队
      });
      console.log("2");

```

```
可以看成：在 JavaScript 执行 宏任务 之前，要先把已入队的 微任务 全部执行完
```



### 15、回调地狱

> 定义:回调函数中嵌套回调函数的情况就叫做回调地狱

> 解决方法:
>
> 使用promise链式调用:
>
> 1、异步函数执行成功，则调用resolve返回成功结果；执行失败，则调用reject返回失败结果。
>
> 2、then中可以接收resolve、reject参数，接收失败结果可以调用catch
>
> 3、每一次then做完处理后就在该函数中return一个新的promise对象，再到下一个then中接收结果

```javascript
function fn(filename){
	return new Promise(function(resolve,reject){
		//readFile(path,[encoding],callback)  异步读取文件全部内容
		let content=fs.readFile(path.join(dirname,filename),'utf8',(err,data)=>{
			if(err){
				console.log(filename+' 读取失败');
				reject(err);
			}else{
				resolve(filename+' 读取完成 : '+data);
			}
		})
	})
}

console.log('多个异步读取文件变成同步执行');

fn('1.txt').then(msg=>{
	console.log(msg);
	return fn('2.txt');
}).then(msg=>{
	console.log(msg);
	return fn('3.txt');
}).then(msg=>{
	console.log(msg);
}).catch(err=>{
	console.log(err);
})
```



### 16、框架

> 框架是一个可复用设计，可以**简单、高效**地提高开发效率。



### 17、Webpack

> 定义:是当下最热门的前端**资源模块化管理**和**打包工具**。



### 18、gulp与webpack区别

> gulp是执行的是一个任务，单个进行打包 ；webpack是对整个模块整体打包



### 19、Ajax

>  定义:Ajax是网页在不刷新的情况下与 Web 服务器**交换数据来异步更新网页**的一种技术。



### 20、浏览器内核

> 定义:主要分成两部分:渲染引擎(layout engineer或Rendering Engine)和JS引擎。
>
> "渲染引擎"用来解释网页语法并渲染到网页上
>
> "JS引擎"用来解析和执行javascript来实现网页的动态效果

| 浏览器  |  内核   | 备注                                                         |
| :------ | :-----: | :----------------------------------------------------------- |
| IE      | Trident |                                                              |
| firefox |  Gecko  |                                                              |
| Safari  | webkit  |                                                              |
| chrome  |  blink  | chrome的内核确切的说是Chromium引擎，它是使用苹果公司的WebKit作为浏览器内核原型，是WebKit内核的一个分支 |
| Opera   |  blink  |                                                              |

> chromium引擎虽然是属于WebKit的分支，却把WebKit的代码梳理得可读性提高很多



### 21、遵循WEB标准的好处

1. 更容易被搜寻引擎搜索
2. 降低网站流量费用
3. 使网站更易于维护
4. 提高页面浏览速度



### 22、WEB三层结构

> 结构（html）、表现（css）、行为（javascript）



### 23、NodeJS

> 是一个基于 Chrome V8 引擎的 JavaScript 运行时。Node.js 是运行在服务端的 JavaScript。



### 24、事件委托

> 如:一个子元素将一个事件委托到它的父层上，真正绑定事件的是父元素。当事件响应时，就会冒泡到父元素，然后在父元素上执行。



### 25、vue-cli与webpack的关系

> vue-cli整合了webpack的配置



### 26、XHTML

> XHTML 指的是可扩展超文本标记语言。
>
> XHTML是严格版本的HTML，例如它要求标签必须小写，标签必须被正确关闭，标签顺序必须正确排列，对于属性都必须使用双引号等。



### 27、Javascript单线程

> JS是单线程语言，因为在设计之初只是用来做表单验证，不需要多线程。如果是多线程，A线程修改数据，B线程删除数据，难以解决同步问题
>
> 浏览器可以多线程，比如js引擎线程，ui渲染线程，浏览器事件触发线程，定时器触发线程，执行同步任务总在异步任务前执行



### 28、new操作符

> 1. 在内存中开辟了一个空间，创建了一个空对象
>
> 2.  为空对象设置原型链
> 3.  执行构造函数，this指向空对象
> 4. 返回新对象



### 29、数组去重三种方法

> 1. 双重for循环原始  找出所有没有重复的字符

```javascript
//双重for循环原始  找出所有没有重复的字符
var arr5 = ['a', 'b', 'c', 'b', 'd', 'a', 'c', 'e'];
var temp = [];
for (var i = 0; i < arr5.length; i++) {
	var flag = true;
	for (var j = 0; j < arr5.length; j++) {
		if (arr5[i] == arr5[j] && i != j) {
			flag = false;
			break;
		}
	}
	if (flag) {
		temp.push(arr5[i]);
	}
}
console.log(temp);
```

> 2. 使用indexOf和lastIndexOf

```javascript
//使用indexOf和lastIndexOf优化代码
temp=[];
$.each(arr5,function(index,item){
	if(arr5.indexOf(item)==arr5.lastIndexOf(item)){
		temp.push(item);
	}
})
```

> 3. 使用Set

```javascript
//Set结构类似数组，但成员值唯一
const set = new Set([1, 2, 3, 3, 3]);
console.log(set, set.size); //Set类型:[1,2,3]  3

//使用剩余参数转化为Array类型
let arr = [...new Set([7, 8, 9, 9, 9])];
console.log(arr, arr.length); //Array类型:[7,8,9]  3
```



### 30、vue修饰符

```html
<!-- 阻止单击事件继续传播 -->
<a v-on:click.stop="doThis"></a>

<!-- 提交事件不再重载页面 -->
<form v-on:submit.prevent="onSubmit"></form>

<!-- 修饰符可以串联 -->
<a v-on:click.stop.prevent="doThat"></a>

<!-- 只有修饰符 -->
<form v-on:submit.prevent></form>

<!-- 添加事件监听器时使用事件捕获模式 -->
<!-- 即内部元素触发的事件先在此处理，然后才交由内部元素进行处理 -->
<div v-on:click.capture="doThis">...</div>

<!-- 只当在 event.target 是当前元素自身时触发处理函数 -->
<!-- 即事件不是从内部元素触发的 -->
<div v-on:click.self="doThat">...</div>
```



### 31、插槽

> 在组件中使用<v-slot>插槽留一个占位，使用组件时，可以在标签之间写其他内容
>
> 具名插槽(作用域插槽等等...):

**使用插槽:**

```html

<div class="container">
  <header>
    <slot name="header"></slot>
  </header>
  <main>
    <slot></slot> <!-- 默认的name="default" -->
  </main>
  <footer>
    <slot name="footer"></slot>
  </footer>
</div>
```

**提供内容:**

```html
<base-layout>
  <template v-slot:header>
    <h1>我是头部</h1>
  </template>

  <p>我是身体</p><!-- 默认的v-slot:default -->

  <template v-slot:footer>
    <p>我是尾部</p>
  </template>
</base-layout>
```

**最后渲染出:**

```html
<div class="container">
  <header>
    <h1>我是头部</h1>
  </header>
  <main>
    <p>我是身体</p>
  </main>
  <footer>
    <p>我是尾部</p>
  </footer>
</div>
```

作用域插槽：







### 32、继承

1. 原型链继承
2. 构造函数继承
3. 组合继承(1与2的组合)
4. 原型式继承
5. 寄生式继承
6. 寄生组合式继承
7. ES6的extends关键字继承

```javascript
// 借用构造函数增强子类实例属性（支持传参和避免篡改）
function Child(name,age){
    // 继承属性
    Parent.call(this, name)
    this.age=age
}
function inheritPrototype(Child, Parent){
    var prototype=Object.create(Parent.prototype);
    prototype.constructor=Child;
    Child.prototype=prototype;
}
// 将父类原型指向子类，这样子类就能使用父类原型链的属性/方法
inheritPrototype(Child, Parent);
```



### 33、Vuex

**commit:同步操作**

> 存储（组件中提交Mutaions）:this.$store.commit('mutation方法',参数) 
>
> 取值（组件中获取State）:this.$store.state.state属性



**dispatch:异步操作**

> 存值（组件中提交Actions）:this.$store.dispatch('action方法',参数)
>
> 取值（组件中获取Getters）:this.$store.getters.getters方法



### 34、代码重构

> 通过调整程序代码改善软件的质量、性能，使其程序的设计模式和架构更趋合理，提高软件的扩展性和维护性。



### 35、三次握手，四次挥手

**三次握手确认对端没问题:**

**第一次握手:**客户端发送网络包，服务端收到了。

> 服务端得出结论:客户端的发送能力、服务端的接收能力是正常的。

**第二次握手:**服务端发包，客户端收到了。

> 客户端得出结论:服务端的接收、发送能力，客户端的接收、发送能力是正常的。

**第三次握手:**客户端发包，服务端收到了。

> 服务端得出结论:客户端的接收、发送能力，服务端的发送、接收能力是正常的。

**四次挥手关闭双工:**

**第一次挥手:**客户端 -- FIN --> 服务端， FIN—WAIT**（客户端:我数据发完了，可以关闭连接了）**

**第二次挥手:**服务端 -- ACK --> 客户端， CLOSE-WAIT**（服务端:收到了，但我的数据还没发完，再等等...）**

**第三次挥手:**服务端 -- ACK,FIN --> 客户端， LAST-ACK**（服务端:我的数据发完了，我关闭连接了）**

**第四次挥手:**客户端 -- ACK --> 服务端，CLOSED**（客户端:收到，大哥！）**



### 36、防抖和节流

> **防抖:**当调用动作过n毫秒后，才会执行该动作，若在这n毫秒内又调用此动作则将重新计算执行时间。(**停留几毫秒再执行，防止抖动**)

为了将多次高频操作优化为只在最后一次执行，如:用户输入文本，只需要在输入完成后校验即可。



> **节流:**预先设定一个执行周期，当调用动作的时刻大于等于执行周期则执行该动作，然后进入下一个新周期。(**设置时间区间，同一时间区间内只执行一次**)

间隔一段时间后执行一次，即，将高频操作优化为低频操作，如:滚动条事件，间隔100~200ms执行一次即可。



### 37、语法糖

> **语法糖:**为了避免程序员出现编写错误并提高效率的一种便捷写法，可以让代码写起来更简单，看起来更容易理解。不用语法糖也程序也不影响。

如（箭头函数）:

```javascript
//这一行等于下面三行
input.map(item => item + 1);

input.map(function (item) {
  return item + 1;
});
```

再如(乘法就是最简单的语法糖):

```javascript
let a=3*5;
let a=3+3+3+3+3;
```



### 38、eval

> 功能:将对应的字符串解析为js代码执行。
>
> 缺点:不安全；因为一次解析为js语句，一次执行，非常消耗性能



### 39、0.1+0.2!=0.3

> 因为js使用的双精度浮点，所以在计算机内部存储数据的编码会出现误差，导致0.1+0.2=0.30000000000000004

**解决方法:**

可以使用toFixed(1)来保留小数点后位数



### 40、语法作用域和动态作用域

> **词法作用域:**是在定义时确定的。
>
> **动态作用域:**是在运行时确定的。



### 41、类数组与数组

**类数组:**

1. 使用数字作为属性名
2. 具备length属性

如:

```javascript
const arrayLike = {
  0:'张三',
  1:'李四',
  length:2
}
```

> **区别:**类数组没有数组的push，pop，shift等方法。

类数组转化为数组三种方法:

```javascript
			console.log('---------------------   类数组转换为数组实现求和(ES5)   ----------------------');
			//方法一:
			function sum(){
				let args=Array.prototype.concat.apply([],arguments);
				console.log(args.reduce((arr,curValue)=>arr+curValue));//15
			}
			
			sum(1,2,3,4,5);
			
			//方法二:
			function sum2(){
				let args=[].slice.call(arguments);
				console.log(args.reduce((arr,curValue)=>arr+curValue));//40
			}
			
			sum2(6,7,8,9,10);
			
			console.log('---------------------   类数组转换为数组实现求和(ES6)   ----------------------');
			function sum(...args){
				console.log(args instanceof Array);//true，剩余参数的原型是Array
				console.log(args.reduce((arr,curValue)=>arr+curValue));//15
			}
			
			sum(1,2,3,4,5);
			
			console.log('---------------------   使用Array.from转换类数组   ----------------------');
			
			// 方法三:
			function sum3(){
				const arr=Array.from(arguments);
				console.log(arr);
			}
			sum3(1,2,3);
```



### 42、变量提升和暂时性死区

> var会变量提升
>
> let、const没有变量提升，即，暂时性死区:防止在变量声明前就使用这个变量，只有声明变量代码出现才可以使用该变量



### 43、优雅降级、渐进增强

> **优雅降级:**若使用的是旧版本浏览器，则代码会针对旧版本浏览器进行降级处理了，使之在旧式浏览器上以某种形式降级体验却不至于完全不能用。

如:

```css
-moz-box-shadow: 10px 10px 5px #888888; /* 老的 Firefox */
box-shadow: 10px 10px 5px #888888;
```



> **渐进增强:**从被所有浏览器支持的基本功能开始，**逐步添加新版本浏览器才支持的功能**，向页面增加不影响基础浏览器的额外样式和功能的。**当浏览器支持时，它们会自动地呈现出来并发挥作用。**



### 44、重绘与回流

当元素的样式发生变化时，浏览器需要触发更新，重新绘制元素。这个过程中，有两种类型的操作，即重绘与回流。

- **重绘(repaint)**: 当元素样式的改变不影响布局时，浏览器将使用重绘对元素进行更新，此时由于只需要UI层面的重新像素绘制，因此 **损耗较少**。如:outline、visibility、color、background-color
- **回流(reflow)**: 当元素的尺寸、结构或触发某些属性时，浏览器会重新渲染页面，称为回流。此时，浏览器需要重新经过计算，计算后还需要重新页面布局，因此是较重的操作。会触发回流的操作:
  - 页面初次渲染
  - 浏览器窗口大小改变
  - 元素尺寸、位置、内容发生改变
  - 元素字体大小变化
  - 添加或者删除可见的 dom 元素
  - 激活 CSS 伪类（例如::hover）
  - 查询某些属性或调用某些方法
    - clientWidth、clientHeight、clientTop、clientLeft
    - offsetWidth、offsetHeight、offsetTop、offsetLeft
    - scrollWidth、scrollHeight、scrollTop、scrollLeft
    - getComputedStyle()
    - getBoundingClientRect()
    - scrollTo()

**回流必定触发重绘，重绘不一定触发回流。重绘的开销较小，回流的代价较高。**



### 45、内存泄露

- 意外的**全局变量**: 无法被回收
- **定时器**: 未被正确关闭，导致所引用的外部变量无法被释放
- **事件监听**: 没有正确销毁 (低版本浏览器可能出现)
- **闭包**: 会导致父级中的变量无法被释放
- **dom 引用**: dom 元素被删除时，内存中的引用未被正确清空

可用 chrome 中的 timeline 进行内存标记，可视化查看内存的变化情况，找出异常点。



### 46、语义化的HTML

> 即，让标签有自己的含义。

优点:

1. 在没有css时，也能很好地呈现出内容结构
2. 有利于爬虫抓取有效信息和确定关键字权重
3. 方便屏幕阅读器、盲人阅读器、RSS阅读器解析渲染网页
4. 便于团队开发维护，使其更具可读性，减少差异化



### 47、清除浮动

> 为了解决子元素浮动引起父元素内部高度为0的问题

1. 在最后一个浮动标签后追加一个标签，设置其clear:both;

2. 父元素设置overflow:hidden

3. 伪元素清除

   ```
   .clear:after{
   	visibility: hidden;
   	clear: both;
   	height: 0;
   	content: ".";
   	display: block;
   }
   ```

4. 双伪元素清除（推荐）

```
.clearfix::before,
.clearfix::after {
	display: table;
	content: "";
}

.clearfix::before {
	clear: both;
}

.clearfix {
	*zoom: 1;
}

```



### 48、px、em、rem

> **px**:像素，相对于屏幕分辨率而言的绝对单位
>
> **em**:相对于当前标签内font-size，若没有设置则相对于继承父元素的font-size
>
> **rem**:相对于HTML根元素font-size



### 49、display

> **none**:此元素不显示。不保留空间
> **block**:将元素显示为块级元素，前后会带换行符,一行展示一个，宽高可以设置。
> **inline**:默认值，元素会被显示为内联元素，前后没有换行符一行展示多个，宽高不能设置。
> **inline-block**:行内块级元素一行展示多个，可设置宽高。
> **Table**: 作为表格块级元素显示
> **Flex**: 弹性盒子



### 50、position(四种定位)

> **Static**: 所有标准流的元素都是静态定位
> **Relative**: **占据**原来的位置，配合top、right、bottom、left使用以原来的位置计算偏移量
> **Absolute**:**不占据**原来的位置，配合top、right、bottom、left使用以最近一个relative父元素计算偏移量 
> **Fixed**:相对于浏览器的边框 滚动滚动条还是会固定



### 51、css继承属性

>  font
>
> font-family
>
> font-size
>
>  font-style
>
> font-variant
>
> font-weight
>
> color
>
> line-height
>
> letter-spacing
>
>  list-style
>
> list-style-image
>
> list-style-position
>
> list-style-type



### 52、框架与插件

**框架**:是项目开发过程中提取特定领域共性部分形成的体系结构，不同领域软件项目有不同框架类型，框架是一个提供了诸多服务，供开发人员进行二次开发，实现具体功能的程序实体。

**插件**:属于组件，增加应用程度的一些特定功能，依赖于应用程序，本身无法正常运行。



### 53、CSS3新特性

> 选择器:nth-child
> Font-face 可以用来加载字体样式
> 圆角border-radius
> 阴影box-shadow
> 渐变gradient
> 弹性盒子 
>
> 过渡、动画
> 媒体查询

新增伪类:

> :root 选择文档的根元素，等同于 html 元素
> :empty 选择没有子元素的元素
> :target 选取当前活动的目标元素
> :disabled 选择禁用的表单元素
> :checked 选择被选中的表单元素
> :before在元素内部前面添加内容
> :after  在元素内部最后添加内容
> :nth-child(n) 匹配父元素下指定子元素，在所有子元素中排序第n
> :nth-child(odd)
> :nth-child(even)
> :nth-child(3n+1)
> :first-child
> :last-child
> :only-child
> :nth-of-type(odd)
> :nth-of-type(even)
> :nth-of-type(3n+1)
> :first-of-type
> :last-of-type
> :only-of-type
> ::selection 选择被用户选取的元素部分
> :first-line 选择元素中的第一行
> :first-letter 选择元素中的第一个字符



### 54、ES6新特性

> 1、变量声明
> 2、模板字符串
> 3、解构赋值
> 4、展开运算符
> 5、箭头函数 
> 6、函数传参设置默认值
> 7、class 类的继承
> 8、扩展运算符
> 9、promise的用法
> 10、set
> 11、map
> 12、数组的新方法 



### 55、HTML5新特性

> * HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加。
>       绘画 canvas;
>       用于媒介回放的 video 和 audio 元素;
>       本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失;
>       sessionStorage 的数据在浏览器关闭后自动删除;
>       语意化更好的内容元素，比如 article、footer、header、nav、section;
>       表单控件，calendar、date、time、email、url、search;
>       新的技术webworker, websocket, Geolocation;
>
>   移除的元素:
>       纯表现的元素:basefont，big，center，font, s，strike，tt，u;
>       对可用性产生负面影响的元素:frame，frameset，noframes；
>
> * 支持HTML5新标签:
>      IE8/IE7/IE6支持通过document.createElement方法产生的标签，
>      可以利用这一特性让这些浏览器支持HTML5新标签，
>      浏览器支持新标签后，还需要添加标签默认的样式。
>
>      当然也可以直接使用成熟的框架、比如html5shim;
>      
> * 如何区分HTML5: DOCTYPE声明\新增的结构元素\功能元素



### 56、预处理器、后处理器

> **css预处理**器:如scss和less，为CSS增加了一些编程的特性，将CSS作为目标生成文件，然后开发者就只要使用这种语言进行编码工作，**编译前** 与 **编译后** 是完全不同的语言。
>
> **CSS 后处理器**:目前最常做的是给CSS属性添加浏览器私有前缀，实现跨浏览器兼容性的问题。如postcss
>
>  `Autoprefixer` 为例:

```css
.container {
	display: flex;
}
.item {
	flex: 1;
}
```

生成兼容性生产环境css:

```css
.container {
	display: -webkit-box;
	display: -webkit-flex;
	display: -ms-flexbox;
	display: flex;
}
.item {
	-webkit-box-flex: 1;
	-webkit-flex: 1;
	-ms-flex: 1;
	flex: 1;
}
```



### 57、相邻两个inline-block节点出现间隔

> 元素被当成行内元素排版的时候，元素之间的空白符（空格、回车换行等）都会被浏览器处理，HTML代码中的回车换行被转成一个空白符，在字体不为0的情况下，**空白符占据一定宽度**，所以inline-block的元素之间就出现了空隙



### 58、websocket

> **WebSocket** : HTML5 开始提供的一种在单个 TCP 连接上进行全双工通讯的协议

```javascript
WebSocket 使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在 WebSocket API 中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输

现在，很多网站为了实现推送技术，所用的技术都是 Ajax 轮询。轮询是在特定的的时间间隔（如每1秒），由浏览器对服务器发出HTTP请求，然后由服务器返回最新的数据给客户端的浏览器。这种传统的模式带来很明显的缺点，即浏览器需要不断的向服务器发出请求，然而HTTP请求可能包含较长的头部，其中真正有效的数据可能只是很小的一部分，显然这样会浪费很多的带宽等资源

HTML5 定义的 WebSocket 协议，能更好的节省服务器资源和带宽，并且能够更实时地进行通讯。
```



### 59、css层叠等级

> background/border < z-index为负值 < 块级元素 < 浮动元素 < 行内元素 < z-index:0 < z-index为正值



### 60、选择器优先级

> `!important` > 行内样式 > `#id` > `.class` > `tag` > * > 继承 > 默认



### 61、v-model原理

> **数据劫持：** 使用ES5的Object.defineProperty()来劫持各属性的getter()、setter()
>
> **发布-订阅者模式:** 发布者在数据发生变化时，通知订阅者。订阅者可以接收发布者发送的通知，触发监听回调绑定的事件，更新视图

```
- 在初始化 data props 时，递归对象，给每一个属性双向绑定，对于数组而言，会拿到原型重写函数，实现手动派发更新。因为函数不能监听到数据的变动，和 proxy 比较一下
- 除了以上数组函数，通过索引改变数组数据或者给对象添加新属性也不能触发，需要使用自带的set 函数，这个函数内部也是手动派发更新
- 在组件挂载时，会实例化渲染观察者，传入组件更新的回调。在实例化过程中，会对模板中的值对象进行求值，触发依赖收集。在触发依赖之前，会保存当前的渲染观察者，用于组件含有子组件的时候，恢复父组件的观察者。触发依赖收集后，会清理掉不需要的依赖，性能优化，防止不需要的地方去重复渲染
- 改变值会触发依赖更新，会将收集到的所有依赖全部拿出来，放入 nextTick 中统一执行。执行过程中，会先对观察者进行排序，渲染的最后执行。先执行 beforeupdate 钩子函数，然后执行观察者的回调。在执行回调的过程中，可能 watch 会再次 push 进来，因为存在在回调中再次赋值，判断无限循环
```

```
由于是在不同的数据上触发同步，可以精确的将变更发送给绑定的视图，而不是对所有的数据都执行一次检测。

- Observer 数据监听器
负责对数据对象的所有属性进行监听（数据劫持），监听到数据发生变化后通知订阅者。

- Compiler 指令解析器
扫描模板，并对指令进行解析，然后绑定指定事件。

- Watcher 订阅者
关联Observer和Compile，能够订阅并收到属性变动的通知，执行指令绑定的相应操作，更新视图。Update()是它自身的一个方法，用于执行Compile中绑定的回调，更新视图。
```



### 62、webworker

现代浏览器为`JavaScript`创造的 **多线程环境**。可以新建并将部分任务分配到`worker`线程并行运行，两个线程可 **独立运行，互不干扰**，可通过自带的 **消息机制** 相互通信。

**基本用法:**

```js
// 创建 worker
const worker = new Worker('work.js');

// 向 worker 线程推送消息
worker.postMessage('Hello World');

// 监听 worker 线程发送过来的消息
worker.onmessage = function (event) {
  console.log('Received message ' + event.data);
}
复制代码
```

**限制:**

- 同源限制
- 无法使用 `document` / `window` / `alert` / `confirm`
- 无法加载本地资源



### 63、浏览器缓存

> 浏览器缓存策略分为两种:强缓存和协商缓存。

> **好处**:良好的缓存策略可以降低资源的重复加载提高网页的整体加载速度。

#### 1. 强缓存

实现强缓存可以通过两种响应头实现:`Expires` 和 `Cache-Control` 。强缓存表示在缓存期间不需要请求，`state code` 为 200

```
Expires: Wed, 22 Oct 2018 08:41:00 GMT
复制代码
```

`Expires` 是 HTTP / 1.0 的产物，表示资源会在 `Wed, 22 Oct 2018 08:41:00 GMT` 后过期，需要再次请求。并且 `Expires` 受限于本地时间，如果修改了本地时间，可能会造成缓存失效。

```
Cache-control: max-age=30
复制代码
```

`Cache-Control` 出现于 HTTP / 1.1，优先级高于 `Expires` 。该属性表示资源会在 30 秒后过期，需要再次请求。



#### 2. 协商缓存

如果缓存过期了，我们就可以使用协商缓存来解决问题。协商缓存需要请求，如果缓存有效会返回 304。

协商缓存需要客户端和服务端共同实现，和强缓存一样，也有两种实现方式。

**Last-Modified 和 If-Modified-Since**

`Last-Modified` 表示本地文件最后修改日期，`If-Modified-Since` 会将 `Last-Modified` 的值发送给服务器，询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来。

但是如果在本地打开缓存文件，就会造成 `Last-Modified` 被修改，所以在 HTTP / 1.1 出现了 `ETag` 。

**ETag 和 If-None-Match**

`ETag` 类似于文件指纹，`If-None-Match` 会将当前 `ETag` 发送给服务器，询问该资源 `ETag` 是否变动，有变动的话就将新的资源发送回来。并且 `ETag` 优先级比 `Last-Modified` 高。



#### 3. 选择合适的缓存策略

对于大部分的场景都可以使用强缓存配合协商缓存解决，但是在一些特殊的地方可能需要选择特殊的缓存策略

- 对于某些不需要缓存的资源，可以使用 `Cache-control: no-store` ，表示该资源不需要缓存
- 对于频繁变动的资源，可以使用 `Cache-Control: no-cache` 并配合 `ETag` 使用，表示该资源已被缓存，但是每次都会发送请求询问资源是否更新。
- 对于代码文件来说，通常使用 `Cache-Control: max-age=31536000` 并配合策略缓存使用，然后对文件进行指纹处理，一旦文件名变动就会立刻下载新的文件。



### 64、公钥加密、密钥加密

> **私钥**用于对数据进行签名
>
> **公钥**用于对签名进行验证
> HTTP网站在浏览器端用公钥加密敏感数据，然后在服务器端再用私钥解密。



### 65、检测当前浏览器版本

```javascript
navigator.userAgent
```

> 输出:Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/93.0.4577.63 Safari/537.36



### 66、单页面应用（SPA）

> 单页[Web](https://baike.baidu.com/item/Web/150564)应用（single page web application，SPA），就是只有一张Web页面的应用。单页应用程序 (SPA) 是加载单个HTML 页面并在用户与应用程序交互时动态更新该页面的Web应用程序。
>
>  浏览器一开始会加载必需的HTML、CSS和JavaScript，所有的操作都在这张页面上完成，都由JavaScript来控制。因此，对单页应用来说模块化的开发和设计显得相当重要。



### 67、数据代理、事件代理

> **数据代理:**通过一个对象代理对另一个对象中属性的操作（如:要修改对象 `a` ，可用对象 `b` 来修改对象 `a` ）
>
> **事件代理:**将事件交给父元素触发，父元素只用判断事件对应的子元素（如:给有 9999 个子元素 <li> 的父元素 <ul> 绑定一个事件，让事件在父元素上触发，而不是给 9999 个 <li> 绑定事件）

**数据代理:**将一个 Object 传入 Vue 实例作为 `data` 选项，Vue 将遍历此对象所有的 property，并使用 `Object.defineProperty()` 将对象 property 全部转为 `setter()和getter()`



### 68、浏览器架构

- 用户界面
- 主进程
- 内核
  - 渲染引擎
  - JS 引擎
    - 执行栈
  - 事件触发线程
    - 消息队列
      - 微任务
      - 宏任务
  - 网络异步线程
  - 定时器线程



### 69、事件循环（Event Loop）

```
运行机制:
1. 执行一个宏任务（栈中没有就从事件队列中获取） 
 2. 执行过程中如果遇到微任务，就将它添加到微任务的任务队列中 
 3. 宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行） 
 4. 当前宏任务执行完毕，开始检查渲染，然后GUI线程接管渲染 
 5. 渲染完毕后，JS线程继续接管，开始下一个宏任务（从事件队列中获取）
```

```
执行顺序:先宏后微
宏任务（发起者:宿主（Node、浏览器））
script(整体代码)、setTimeout、setInterval、setImmediate(Node.js 环境)、UI事件、I/O（Node.js）

微任务（发起者: JS引擎）
Promise、MutaionObserver、process.nextTick（Node.js）

```



### 70、 Vue的 nextTick 原理

`nextTick` 可以让我们在下次 DOM 更新循环结束之后执行延迟回调，用于获得更新后的 DOM。

在 Vue 2.4 之前都是使用的 microtasks，但是 microtasks 的优先级过高，在某些情况下可能会出现比事件冒泡更快的情况，但如果都使用 macrotasks 又可能会出现渲染的性能问题。所以在新版本中，会默认使用microtasks,但在特殊情况下会使用 macrotasks，比如 v-on。



### 71、MVC、MVP、MVVM

```
MVC
- Model:管理数据
- View:负责数据的展示，把事件传递给Controller，Controller 触发Model层的事件，Model更新完数据（网络或者本地数据）之后触发View的更新事件。
- controller:负责业务逻辑

MVP
- Model:管理数据
- View:提供接口给Presenter，Presenter更新Model，View通过观察者模式更新View(View不依赖Model，可抽离出来做组件)
- Presenter:除了业务逻辑外，还需要帮View和Model做数据同步（一旦View需求改变，Presenter也要改变，维护困难）

MVVM
- Model:管理数据（类似json数据对象）			
- View:通过使用模板语法来声明式的将数据渲染进DOM，VM对M更新时，通过数据绑定更新View
- ViewModel(Model of View):M和V的数据同步交给框架提供的数据绑定功能负责，只用指明V与M的数据对应即可（M和V因数据绑定自动更新同步）

目前一些主流的前端框架实现数据绑定的方式大致有以下几种:
- 数据劫持 (Vue)
- 发布-订阅模式 (Knockout、Backbone)
- 脏值检查 (Angular)
```



### 72、性能优化

####  网络方面

1. **减少http请求**:优化js、css和图片资源

   ```
   - 合并js、css文件
   - 雪碧图的使用
   - base64编码表示简单图片（base64编码就是可以将图片数据编码成字符串，使用字符串代码图片src），如:5px*5px的base54图片平铺当背景图
   ```

2. **减小资源体积**

   ```
   - gzip压缩:将html中重复的部分进行一个打包，多次复用
   - js混淆:将空白字符删除、变量缩小、
   - css压缩
   - 图片压缩
   ```

3. **缓存**

   ```
   - DNS缓存:DNS服务器解析出IP后，系统会将这个结果临时储存起来，并为它设置一个失效时间（n小时），未失效时，将从本地缓存中读取结果
   - CDN部署与缓存:浏览器会在本地保存网站中的静态资源，再次访问网站时，就不用下载全部文件
   - http缓存:给缓存的资源设定缓存时间，防止在缓存时间内多次下载重复资源
   ```

4. **移动端优化**

   ```
   - 使用长cache，减少重定向
   - 首屏优化，保证首屏加载数据小于14kb,速度小于2s
   - 不滥用web字体
   ```

####  渲染和DOM操作方面

1. **优化网页渲染**

   ```
   - 渲染的文件放在头部，数据操作文件放在尾部或异步
   - 尽量避免内联样式（减小html体积）
   ```

2. **DOM操作优化**

   ```
   - 避免在document上直接进行频繁的DOM操作
   - 使用classname代替大量的内联样式修改
   - 对于复杂的UI元素，设置position为absolute或fixed
   - 事件代理
   ```

3. **操作细节**

   ```
   - 在css属性为0时，去掉单位
   - 避免图片或者frame使用空src
   - 禁止图像缩放
   - 移除空的css规则
   - css中可继承的属性多继承
   - 多使用伪元素等帮助定位
   ```

4. **移动端优化**

   ```
   - 长列表下拉懒加载
   - touchstart、touchend代替click（click移动端有300ms延时）
   - 函数防抖和函数节流
   - HTML的viewport设置
   - 开启GPU渲染加速
   ```

####  数据方面

1.**图片加载处理**

```
- 图片预加载(图片漫画展示时。往往会预加载一张到两张的图片)
- 图片懒加载(随着用户的滚动，随即显示的。或最初给图片的src设置一个比较简单的图片，然后将图片的真实地址设置给自定义的属性，做一个占位，然后给图片设置监听事件，   一旦图片到达视口范围，从图片的自定义属性中获取出真是地址，然后赋值给src，让其进行加载。)
- 首屏进度条
```

2.**异步请求的优化**

```
- 数据埋点和统计
```

3.**webpack打包文件体积过大**

```js
- 异步加载模块
- 提取第三库
- 代码压缩
- 去除不必要的插件
```

4.**优化webpack构建的性能**

```js
一、减少代码体积 1.使用CommonsChunksPlugin 提取多个chunk之间的通用模块，减少总体代码体积
		 2.把部分依赖转移到CDN上，避免每次编译过程都由Webpack处理
		 3.对一些组件库采用按需加载，避免无用的代码
二、减少目录检索范围
		 ·在使用loader的时候，通过制定exclude和include选项，减少loader遍历的目录范围，从而加快webpack编译速度
三、减少检索路经:resolve.alias可以配置webpack模块解析的别名，对于比较深的解析路经，可以对其配置alias
```



### 73. scoped作用

> 防止 style 穿透。 使用 `>>> `或`/deep/`来穿透样式，来修改其他组件的元素样式



### 74. Vue钩子函数

> vue组件生命周期就是从创建到销毁的全过程，共有 `8` 个 ：
>
> beforeCreate->created->beforeMounte->mounted->beforeUpdate->updated->beforeDestroy->destroyed

还有 `<keep-alive>` 的 `3` 个钩子函数：

**activated:** 首页 HelloWorld 不设置缓存，query 设置缓存，当路由从 HelloWord 跳转至 query时，缓存组件被激活，调用 activated 钩子函数

```javascript
//App.vue
<keep-alive exclude="HelloWorld">
   <router-view/>
</keep-alive>

activated () {
    console.log('activated钩子函数被调用')
}
```

**deactivated:** 首页 HelloWorld 不设置缓存，query 设置缓存，当路由从 query 跳转至 HelloWorld 时，缓存组件被停用，调用 deactivated 钩子函数

```javascript
//App.vue
<keep-alive exclude="HelloWorld">
   <router-view/>
</keep-alive>

deactivated () {
    console.log('deactivated钩子函数被调用')
}
```

**errorCaptured:** 当子孙组件出现异常时，该钩子函数会捕获异常。当这个钩子函数返回 false时，会阻止异常进一步向上冒泡，否则会不断向父组件传播。

```javascript
errorCaptured (err, vm, info) {
    console.log(err)
    console.log(vm)
    console.log(info)
}
```



### 75. vue-router路由模式

> history、hash、abstract

```
hash模式:
url路径会出现 # 字符
hash值不包括在 HTTP 请求中，它是交由前端路由处理，所以改变hash值时不会刷新页面，也不会向服务器发送请求
hash值的改变会触发hashchange事件

history模式:
整个地址重新加载，可以保存历史记录，方便前进后退
使用 HTML5 API（旧浏览器不支持）和 HTTP服务端配置，没有后台配置的话，页面刷新时会出现404

abstract模式:
支持所有JavaScript运行环境，如Node.js服务器端，如果发现没有浏览器的API，路由会自动强制进入这个模式。
```



### 76. vue-router导航钩子函数

> 1、router.push()，用来重定向，也可以携带参数
>
> 2、router.replace()，用来替换当前的history记录，不会向history中添加新的记录
>
> 3、router.go()，在history中前进或后退多少步，类似window.history.go(n)



### 77. vue-router路由懒加载

未使用组件懒加载:

```
import HelloWorld from '@/components/HelloWorld'
{
     path: '/',
     name: 'HelloWorld',
     component:HelloWorld
}
```

使用组件懒加载:

```
{
     path: '/',
     name: 'HelloWorld',
     component:()=>import('@/components/HelloWorld')
}
```



### 78. VueRouter路由传参的方式

```
path: "/product/:id",
name: "ProductDetail",
component: () => import("../views/products/product-detail.vue"),
```



### 79. VueRouter编程式导航如何使用

> 除了使用 `<router-link>` 创建 a 标签来定义导航链接，我们还可以借助 router 的实例方法$router.push('/')



### 80. keep-alive组件

> 组件间切换保持组件状态，避免反复渲染导致性能浪费



### 81. vue父组件中调用子组件的方法

1. 给子组件加ref属性，父组件中使用 **this.$refs.child.方法名()** 调用

2. 子组件中:

   ```javascript
   this.$on('say', function() {
       console.log('我是子组件方法');
   });
   ```

   父组件中:

   ```javascript
   this.$refs.child.$emit("say");
   ```



### 82. `computed`和`watch`作用和区别

| 计算属性（computed）             | 监听器(watch)                          |
| -------------------------------- | -------------------------------------- |
| 监听data中没有的值               | 监听data中有的值                       |
| 使用时触发                       | 使用不会触发                           |
| 值有变化就触发                   | 值有变化就触发                         |
| 没有setter，要手动实现           | 有getter和setter，可以获取新和和旧的值 |
| 会缓存计算结果，重新使用不会触发 |                                        |



### 83. 浏览器渲染原理及流程 

> 1. 构建DOM树
>
> 2. 构建CSSOM树  
>
> 3. 构建渲染树（Render Tree） 
>
> 4. 渲染树布局(layout of the render tree)
>
> 5. 渲染树绘制（Painting the render tree）

```
构建DOM树:浏览器接解析HTML文档，将标签与该标签包含的所有属性转换成Node节点并添加到空的DOM树中生成DOM树
  1. 读取HTML字节流，根据指定编码（如UTF-8）将字节流转换成各个字符，并将字符串转换成W3C HTML5标准规定的各	 种令牌
  2. 通过分词器将字节流转换成一个个Token，分为Tag Token和文本Token（如:开始标签P 字符串 结束标签P），这    些Token将会按顺序压到一个Token栈中
  3. 将Token解析为DOM节点，并将DOM节点添加到一个空的DOM树中
  
构建CSSOM树:解析对应的css样式文件，生成Node节点，生成CSSOM树(因为CSS属性覆盖，CSSOM构建后才可被使用)
           与构建DOM树相似，也是1.解析 2. Token 3. 生成Node节点
  JS试图在浏览器还未完成CSSOMTree的构建时去操作CSS样式，浏览器会暂停脚本的运行和DOM的构建，直至浏览器完成了CSSOM构建。也就是说，JS脚本的出现会让CSSOM的构建阻塞DOM的构建。如果在DOM，CSSOM和JavaScript执行之间引入大量的依赖关系，可能会导致浏览器在处理渲染资源时出现大幅度延迟

构建渲染树:当每一个可见的DOM节点被添加到DOM树上时，就会将DOM树节点与CSSOM树节点关联起来，内核就会为它生成          对应的RenderObject（Render树的节点）到Render树上（忽略<html><script><link>和设置了                display:none的DOM节点）

渲染树布局:从Render树的根节点开始遍历，由于每一个RenderObject都包含宽高位置颜色等样式信息，所以浏览器就可           以通过这些样式信息来确定每个节点在页面上在确切大小和位置，输出盒子模型

渲染树绘制:浏览器的UI后端组件从Render树的根节点开始遍历，调用paint()方法在屏幕上显示
```



### 84.css放顶部，js放后面

```
1.浏览器预先加载css后，可以不必等待HTML加载完毕就可以渲染页面了
2.其实HTML渲染并不会等到完全加载完在渲染页面，而是一边解析DOM一边渲染。
3.js写在尾部，主要是因为js主要扮演事件处理的功能，一方面很多操作是在页面渲染后才执行的。另一方面可以节省加载时间，使页面能够更加的加载，提高用户的良好体验

但是随着JS技术的发展，JS也开始承担页面渲染的工作。比如我们的界面可以分别对待，把渲染页面的js放在前面，时间处理的js放在后面
```



### 85. BFC

> BFC（块级格式上下文）:是一个独立的渲染区域，内部元素布局是静态布局



### 86. HTTP和HTTPS


```
HTTPS 默认工作在 TCP 协议443端口，它的工作流程一般如以下方式:

1、TCP 三次同步握手
2、客户端验证服务器数字证书
3、DH 算法协商对称加密算法的密钥、hash 算法的密钥
4、SSL 安全加密隧道协商完成
5、网页以加密的方式传输，用协商的对称加密算法和密钥加密，保证数据机密性；用协商的hash算法进行数据完整性保护，保证数据不被篡改。
```

```
区别:
1.HTTP 明文传输，数据都是未加密的，安全性较差，HTTPS（SSL+HTTP） 数据传输过程是加密的，安全性较好。

2.使用 HTTPS 协议需要到 CA（Certificate Authority，数字证书认证机构） 申请证书，一般免费证书较少，因而需要一定费用。证书颁发机构如:Symantec、Comodo、GoDaddy 和 GlobalSign 等。

3.HTTP 页面响应速度比 HTTPS 快，主要是因为 HTTP 使用 TCP 三次握手建立连接，客户端和服务器需要交换 3 个包，而 HTTPS除了 TCP 的三个包，还要加上 ssl 握手需要的 9 个包，所以一共是 12 个包。

4.http 和 https 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443。

5.HTTPS 其实就是建构在 SSL/TLS 之上的 HTTP 协议，所以，要比较 HTTPS 比 HTTP 要更耗费服务器资源。

```


HTTPS缺点:

```
1、HTTPS 协议握手阶段比较费时，会使页面的加载时间延长近。

2、HTTPS 连接缓存不如 HTTP 高效，会增加数据开销，甚至已有的安全措施也会因此而受到影响。

3、HTTPS 协议的安全是有范围的，在黑客攻击、拒绝服务攻击和服务器劫持等方面几乎起不到什么作用。

4、SSL 证书通常需要绑定 IP，不能在同一 IP 上绑定多个域名，IPv4 资源不可能支撑这个消耗。

5、成本增加。部署 HTTPS 后，因为 HTTPS 协议的工作要增加额外的计算资源消耗，例如 SSL 协议加密算法和 SSL 交互次数将占用一定的计算资源和服务器成本。

6、HTTPS 协议的加密范围也比较有限。最关键的，SSL 证书的信用链体系并不安全，特别是在某些国家可以控制 CA 根证书的情况下，中间人攻击一样可行。
```

```
客户端解析证书
这部分工作是由客户端的 TLS 来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。如果证书没有问题，那么就生成一个对称加密密钥，然后用公钥对该密钥进行非对称加密。

传送加密信息
这部分传送的是用公钥加密后的对称加密密钥，目的就是让服务端得到这个密钥，以后客户端和服务端的通信就可以通过这个密钥来进行加密解密了。

服务端解密信息
服务端用非对称加密算法里的私钥解密后，得到了客户端传过来的对称加密算法的私钥，然后把之后传输的内容通过该值进行对称加密。
```



### 87. 动态路由

>   如果不使用history模式的动态添加路由，那么，用户就可以在地址栏中访问菜单中没有的页面。


> 如果使用了动态添加路由，刷新页面会出现404，解决方法:将当前的路由暂存在sessionStorage中（又会出现问题:管理员将该用户的权限更改，导致路由变更，用户刷新后还是拿的存放在sessionStorage中的旧路由，而不是拿的新路由，只有该用户重新登录，才会根据权限拿到最新的路由）



### 88. W3C标准

1. DOCTYPE文档标准（过渡的、严格的、框架的）:DOCTYPE声明必须放在每一个XHTML文档最顶部，在所有代码和标识之上。

2. 为了被浏览器正确解释和通过W3C代码校验，所有的XHTML文档都必须声明它们所使用的编码语言，我们一般使用gb2312(简体中文)，制作多国语言页面也有可能用Unicode、ISO-8859-1等，根据你的需要定义。

   ```
   <meta http-equiv=“Content-Type” content=“text/html; charset=gb2312” />
   ```

3. Js必须要用<script language="javascript" type="text/javascript">来开头定义

4. CSS必须要用<style type="text/css">开头来定义

5. 所有标签的元素和属性的名字都必须使用小写

6. 所有的属性必须用引号""括起来

7. 特殊符号用编码表示&nbsp；

8. 给所有属性赋一个值

9. 所有的标记都必须要有一个相应的结束标记

10. 所有的标记都必须合理嵌套

11. 图片添加有意义的alt属性

12. 在form表单中增加lable，以增加用户友好度



### 89. 工作流程

**参与讨论**
梳理产品需求:1、产品整体规划 2、需求优先级

产品需求评审:1、当前版本更新点 2、产品需求内部初审 3、产品需求终评

**输出统计文档**

分析产品逻辑:1、需新增/修改的统计项 2、业务方关注的数据指标

统计需求评审:1、统计需求内部初审 2、统计法需求终评

跟进需求开发:1、统计事件埋点 2、数据指标上报规则

功能验收核对:1、核对统计项 2、测试check事件

上线数据监测:1、版本覆盖情况 2、数据是否正常上报 3、数据持续跟踪

**输出版本上线报告**
数据分析总结:1、新版本分析解读 2、目标完成情况

```
产品经理（小公司老板）确定需求，开发主管分配任务

如果有新的需求，产品经理先对开发主管说，开发主管再按照开发计划来为每个人分配任务
```



### 90. 前端工程化的理解

> 前端工程化:是使用**软件工程的技术和方法来进行前端的开发流程、技术、工具、经验等规范化、标准化，其**主要目的 为了提高效率和降低成本，即提高开发过程中的开发效率，减少不必要的重复工作时间



### 91. git常用命令

```
git init 客户端初始化仓库
git init --base 服务端创建一个git仓库
git config --global user.name "username" 初始化用户名
git config --global user.email "email@email.com" 初始化邮箱
git config --global alias.br branch 设置命令别名
git config --list 查看当前配置
git add -A 全部文件添加到暂存区
git commit -m 'feat:xxx' 将已跟踪的修改提交到版本库
git push origin master 推送到远程仓库
git status 查看当前文件状态
git reset --merge 取消本地工作区合并
git show 1c002d 显示这次提交的更改
git rm --cached README 把文件从版本库和暂存区移除
git rm a.txt -f 强制将文件从暂存区移除（系统也删除文件）
git mv a.txt b.txt 文件重命名/移动
git gc 清除不必要文件并优化西仓储存库
git gitk 打开默认图形化工具
git remote show origin 查看远程仓库信息
git remote add myClone https://xxxxx.com/xxx/xxx.git 添加远程仓库，起名
git remote rename origin orn 重命名远程仓库
git remote rm origin 移除远程仓库
git clone https://xxxxx.com/xxx/xxx.git 克隆远程仓库
git pull origin master 拉取分支最新内容
git fetch origin master 拉取远程仓库（不自动合并）
git checkout master 切换分支
git branch test 创建分支
git branch 列出全部分支
git branch -a 查看全部本地分支和远程分支
git branch -v 列出全部分支，并查看每个分支最后一次提交
git branch -d test 删除分支
git branch -D test 强制删除分支
git merge dev 合并分支
git tag 列出现有标签
git tag -d v1.4 删除标签
git diff 44k231d2f HEAD 对比两次提交
git log 查看提交历史
```



### 92. 架构、框架、设计模式、模块、组件、插件、控件、中间件、库

**架构（软件体系结构）**:是一种设计方案，将客户不同需求抽象成为抽象组件，且能够描述组件间的通信与调用。不仅涉及结构与行为，还涉及到系统的使用，功能，性能，适应性，重用性，可理解性等。

**框架**:是项目开发过程中提取特定领域共性部分形成的体系结构，不同领域软件项目有不同框架类型，框架是一个提供了诸多服务，供开发人员进行二次开发，实现具体功能的程序实体。

**设计模式**:是针对单一问题的设计思路和解决方法，是一套被反复使用，多数人知晓的，经过分类编目的，代码设计经验的总结。

**模块**:指的是一段能够实现某个有价值目标的成员代码段。

**组件**:封装了一个或多个实体程序模块的实体，利用接口交互。

**插件**:属于组件，增加应用程度的一些特定功能，依赖于应用程序，本身无法正常运行。

**控件**:可视化组件。

**中间件**:提供系统软件和应用软件间连接的软件，用于应用程序各部件间的沟通。

**库:**是一个封装好的函数的集合



### 93、微信小程序生命周期

```
页面生命周期：
onLoad
onShow
onReady
onHide
onUnload

组件生命周期:
created:组件实例刚刚被创建时执行
attached:组件实例进入页面DOM树执行
ready:组件在渲染树布局完成后执行
moved:组件实例被移动到DOM树另一位置时执行
detached:组件实例从DOM树移除时执行
error:组件方法抛出错误时执行

组件所在页面生命周期:
show:组件所在页面被展示时执行
hide:组件所在页面被隐藏时执行
resize:组件所在页面尺寸变化时执行
```



### 94、捕获阶段、目标阶段、冒泡阶段

> `捕获阶段` 是为了建立传播路径，当事件到达目标节点就进入了 `目标阶段` ，事件触发后就进入了 `冒泡阶段` 回流到window结点



### 95、CSS hack

> 使用原因：针对不同浏览器或不同版本写特定CSS样式

**IE条件注释法**

```html
只在IE下生效
<!--[if IE]>
这段文字只在IE浏览器显示
<![endif]-->
```

**CSS属性前缀法**

```css
    background-color:red; /* All browsers */  
    background-color:blue !important;/* All browsers but IE6 */  
    *background-color:black; /* IE6, IE7 */  
    +background-color:yellow;/* IE6, IE7*/  
    background-color:gray\9; /* IE6, IE7, IE8, IE9, IE10 */  
    background-color:purple\0; /* IE8, IE9, IE10 */  
    background-color:orange\9\0;/*IE9, IE10*/  
    _background-color:green; /* Only works in IE6 */  
    *+background-color:pink; /*  WARNING: Only works in IE7 ? Is it right? */  
```

**选择器前缀法**

```css
*html *前缀只对IE6生效
*+html *+前缀只对IE7生效
```



### 96、前端路由、后端路由

```css
前端路由：改变URL，页面不整体刷新，根据不同地址，展示不同组件。
适用于：主要用于单页面应用程序
优点：页面不刷新，项目使用期间页面不重新加载，实现了前后端分离。
缺点：浏览器的前进后退会重新提交请求，没有合理利用缓存，无法记住前进后退之前页面的滚动位置
```

```css
后端路由：浏览器在地址栏中切换不同的URL时，每次都向后台服务器发出请求，服务器响应请求，渲染好整个页面，并且交页面返回给客户端。
优点：页面渲染和数据拼接都由服务器完成，降低了浏览器压力
缺点：项目庞大时，加大了服务器压力；浏览器不能输入指定的URL路径进行指定模块的访问；网速过慢会延迟页面加载
```



### 97、Object.is和===的区别

```
Object.is()：判断两个值是否为同一个值，返回Boolean
满足以下条件则相等：
1. 都是undefined、null、true或false
2. 都是相同长度字符串 且 相同字符排列相同
3. 都是相同对象，同一引用
4. 都是数字 且 （都是+0 或 都是-0 或 都是NaN 或 都是非零且非NaN且为同一个值）

区别：===和==将数字-0和+0视为相等，而将Number.Nan与NaN视为不相等
```



### 98、Number、BigInt

```
JavaScript中最大安全整数：2的53次方-1
由于Number类型与BigInt类型间相互转换会损失精度，所以建议在值可能大于2的53次方-1时使用BigInt类型，且不在Number与BigInt间进行相互转换
```



### 99、Git flow

##### 1. Git Flow常用分支

- **生产分支（master）**‌

Master分支是仓库的主分支，这个分支包含最近发布到生产环境的代码，最近发布的Release， 这个分支只能从其他分支合并，不能在这个分支直接修改‌

- **补丁分支（hotfix）**‌

当我们在生产环境发现新的Bug时候，我们需要基于master分支创建一个Hotfix分支，然后在Hotfix分支上修复bug，完成Hotfix后，我们要把hotfix分支合并回Master和Develop分支‌

- **发布分支（release)**‌

当你需要发布一个新功能的时候，要基于Develop分支创建一个Release分支，在Release分支测试并修复bug，完成release后，把release合并到master和develop分支‌

- **开发分支（develop）**‌

这个分支是我们的主开发分支，包含所有要发布到下一个Release的代码，这个主要合并与其他分支，比如Feature分支‌

- **功能分支（feature）**‌

feature分支主要是用来开发一个新的功能，一旦开发完成，我们合并回Develop分支进入下一个Release‌

##### 2. Git Flow 使用

当我们新建git仓库之后，默认会创建一个主分支也就是master分支，由于master分支是用于发布生产环境，所有必须保证master上代码的稳定性，所以我们不能直接在master分支上修改提交。我们要基于master分支创建一个develop分支，develop分支用于保存开发好的相对稳定的功能，master分支和develop分支是仓库的常驻分支，一直会保留在仓库中

![image-20211110141732859](D:\Repository\data-sorting\资料整理\imgs\image-20211110141732859.png)

当新的开发任务来了之后，就要编写代码了，我们尽量不要在develop分支上写代码，要保证develop分支的相对稳定，所以这时我要就要基于develop 分支创建一个临时的开发分支，然后在开发分支上编写代码，等功能开发完之后我们再把开发分支合并到develop上

![image-20211110141820157](D:\Repository\data-sorting\资料整理\imgs\image-20211110141820157.png)

新功能合并到develop分支之后，我们想把新功能发布到生产环境，首先基于develop分支创建release分支，然后在release分支测试完成之后，把release分别合并到master分支和develop分支

![image-20211110141838083](D:\Repository\data-sorting\资料整理\imgs\image-20211110141838083.png)

release分支合并到master分支之后，在master分支上打标签用于发布

![image-20211110141856212](D:\Repository\data-sorting\资料整理\imgs\image-20211110141856212.png)

我们把代码发布到了生产环境，用户在使用的时候给我们反馈了一个bug，这时我们需要基于master分支创建一个hotfix 分支，用于修复bug，bug修好之后，把hotfix 分支分别合并到master分支和develop分支

![image-20211110141912675](D:\Repository\data-sorting\资料整理\imgs\image-20211110141912675.png)



### 100、Vue单向数据流

> 父级property的更新会向下流动到子组件，反过来不行，这样可以防止子组件意外改变父组件的状态，从而导致数据流向难以理解。

如：

1. 开发中可能出现多个子组件依赖父组件的某个数据，如果子组件可以修改父组件的数据，那么，一个子组件可能就会让所有依赖这个数据的子组件发生变化，所以，Vue不推荐子组件修改父组件的数据，直接修改会抛出警告
2.  又如，继承Object的子元素修改了原型Object的属性，这样会让所有继承Object的元素都发生变化

**优点：**

1. 所以状态改变可记录，源头可追溯
2. 组件数据只有唯一的入口和出口，使程序更直观，更易理解，更具可维护性

**缺点：**

1. 渲染完成后，出现新数据，就要修改DOM树，模板重新渲染
2. 代码量上升，数据流流程变长



### 101、transition 标签

```
过滤类名：
v-enter：过渡开始动画
v-enter-active：过渡生效时动画
v-enter-to：过渡结束动画
v-leave：离开过渡开始动画
v-leave-active：离开过渡生效时动画
v-leave-to：离开过渡结束动画
```



### 102、虚拟DOM

> 为了解决浏览器性能问题而设计出来的。

如：一个操作要更新10次DOM，虚拟DOM不会立即操作DOM，而是将10交更新的 `diff` 内容保存到本地JS对象中，再由这个JS对象一次性attach到DOM树上，避免大量无谓的计算量。

**虚拟DOM优点：**

1. 保证性能下限，虚拟DOM可以使用diff算法找出最小差异，避免大量无谓的计算量
2. 无需手动操作DOM，虚拟DOM的diff算法是在更新中自动进行的
3. 跨平台，虚拟DOM本质是JS对象，而DOM与平台强关联。如服务器渲染和移动端开发等

**虚拟DOM缺点:**

1. 无法进行极致优化，在一些性能要求极高的应用中虚拟DOM无法进行针对性的极致优化

**diff算法:**

为了虚拟DOM的比较替换效率更高



### 103、JS内置函数

```
(1)alert函数：显示一个警告对话框，包括一个OK按钮。

(2)confirm函数：显示一个确认对话框，包括OK、Cancel按钮。

(3)escape函数：将字符转换成Unicode码。

(4)eval函数：先将字符串转化为JS代码，再将JS代码执行（缺点：1.不安全；2.性能浪费）。

(5)isNaN函数：测试是(true)否(false)不是一个数字。

(6)parseFloat函数：将字符串转换成符点数字形式。

(7)parseInt函数：将符串转换成整数数字形式(可指定几进制)。

(8)prompt函数：显示一个输入对话框，提示等待用户输入。例如：
```



### 104、Babel

> 定义：是一个工具集，主要用于将ES6的 JS 语法转化为ES5等向后兼容的JS代码，从而可以运行在低版本浏览器或其它环境中



### 105、Gulp

> 定义：是一个自动化构建工具，开发者可以使用 Gulp 在项目开发过程中自动执行“重复工作”，如：压缩CSS/JS文件，ES6转化为ES5等

Gulp使用的Node.js中的Stream来读取和操作数据，速度比grunt.js更快。

**优点:**

1. gulp 将开发流程中让人痛苦或耗时的任务自动化，从而减少你所浪费的时间、创造更大价值。

2. 代码优于配置、node 最佳实践、精简的 API 集，gulp 让工作前所未有的简单。

3. 基于 node 强大的流(stream)能力，gulp 在构建过程中并不把文件立即写入磁盘，从而提高了构建速度。

4. 遵循严格的准则，确保我们的插件结构简单、运行结果可控。



### 105、ECharts

> 定义：使用 JavaScript 实现的开源可视化库



### 106、Vue内置指令

```
v-text
v-html
v-show
v-if
v-else
v-else-if
v-for
v-on
v-bind
v-model
v-slot
v-cloak
v-once：只渲染元素和组件一次，之后的重新渲染元素和组件及其所有子节点视为静态内容并跳过渲染
v-pre：跳过这个元素和它的子元素的编译过程
v-bind:is：可用于动态切换组件
```



### 107、Vue自定义指令

> 为了将DOM的逻辑单独委托出来，约定成一些特定的修饰符（使用Vue.directive()方法自定义）

添加自定义指令：

```javascript
<div id="app">
    <div v-resize></div>
</div>

```

写自定义指令:

```javascript
Vue.directive("resize", {
  //只调用一次，指令第一次绑定元素时调用
  bind: function(el, binding, value){},
  //被绑定元素插入父节点时调用
  //（仅保证父节点存在，但不一定已被插入文档中）
  inserted: function(el, binding, vnode){},
  //所在组件的 Vnode 更新时调用
  //但是可能发生在其子 VNode 更新之前
  //指令的值可能发生了变化，也可能没有
  //但是可以通过比较更新前后的值来忽略不必要的模板更新
  update: function(el, binding, vnode, oldVnode){},
  //指令所在的 VNode 及其子 VNode 全部更新后调用
  componentUpdated: function(el, binding, vnode, oldVnode){},
  //只调用一次，指令与元素解绑时调用
  unbind: function(el, binding, vnode){},
});

```



### 108、Lodash

> Lodash 是一个一致性、模块化、高性能的 JavaScript 实用工具库



### 109、uni-app

> 是一个使用 `Vue.js` 开发所有前端应用的框架，编写一套代码，可发布到IOS、Android、Web(响应式)以及各种小程序



### 110、React

> 定义：是一个声明式、高效且灵活的用于构建用户界面的 `JavaScript` 库



### 111、Param、Query

> query接收的表单key-value，是拼接在url后面的参数，没有也可以。
>
> param只接收值，如/:id路由传参，是路由的一部分，必须在路由后面添加参数名。

```javascript
用来接收：this.$route.params.id
```



### 112、常用Array方法

1. concat()连接两个数组

   ```javascript
   [1, 3, 5, 7, 9].concat([2, 4, 6, 8, 10])
   ```

2. forEach()遍历数组

   ```javascript
   [1, 2, 3, 4, 5, 6, 7, 8].forEach(function(el, index) {
   	console.log('arr[' + index + '] = ' + el + '  ' + this);
   })
   ```

3. includes(value) ES7新增 判断是否包含该值

   ```javascript
   ['aa', 'bb', 'cc', 'bb', 'dd'].includes('aa')
   ```

4. indexOf(value,[startIndex]) 从前向后查找该值的索引(不存在返回-1)

   ```javascript
   ['aa', 'bb', 'cc', 'bb', 'dd'].indexOf('bb')
   ```

5. lastIndexOf(value,[startIndex]) 从后向前查找该值的索引(不存在返回-1)

   ```javascript
   ['aa', 'bb', 'cc', 'bb', 'dd'].lastIndexOf('bb')
   ```

6. map(function(){})  参数为一个匿名函数 循环遍历原数组时 每个元素作为匿名函数参数来处理并改变每个原始元素

   ```javascript
   //将原数组每个元素 *2
   [1, 3, 5, 7, 9].map(function(item) {
   	return item * 2;
   })
   // 获取原数组每个元素的ASCII码
   'Hello'.split('').map(function(item) {
   	return item.charCodeAt(0);
   })
   ```

7. reduce(function(){accumulator, currentValue, currentIndex, array}) 累加器

   ```javascript
   //reduce  数组所有元素累加
   [1, 3, 5, 7, 9].reduce(function(acc,curValue) {
   	return acc + curValue;
   })
   ```

8. slice(startIndex,endIndex) 浅拷贝数组  范围:[startIndex,endIndex)

   ```javascript
   [1, 2, 3, 4, 5, 6, 7, 8].slice(2, 3)	
   ```

9. filter()  创建一个通过过滤的所有元素的新数组

   ```javascript
   //过滤出元素长度大于5的数组
   ['zhangsan', 'lisi', 'wangwu', 'zhaoliu'].filter(item => item.length > 5);
   ```

10. isArray() 判断是否是Array类型

    ```javascript
    Array.isArray([1, 2, 3]) //true
    ```

11. pop() 弹出数组最后一个元素（<b style="color:#dc4e41">改变原数组</b>）

    ```javascript
    [1, 2, 3, 4, 5].pop() //'5'
    ```

12. push() 在数组尾部新增一个元素（<b style="color:#dc4e41">改变原数组</b>）

    ```javascript
    [1, 2, 3, 4, 5].push(6) //'6'
    ```

13. reverse() 数组反转（<b style="color:#dc4e41">改变原数组</b>）

    ```javascript
    [1, 3, 5, 7, 9].reverse() //'9,7,5,3,1'
    ```

14. sort(function(){}) 参数为匿名函数，可升序和逆序排序（<b style="color:#dc4e41">改变原数组</b>）

    ```javascript
    [1, 3, 5, 2, 4, 7, 9, 6, 8].sort((n1, n2) => n1 - n2);//升序
    ```

15. shift()  删除第一个元素，返回删除的元素(<b style="color:#dc4e41">改变原数组</b>)

    ```javascript
    [1, 2, 3, 4, 5].shift() //'1'
    ```

16. splice(startIndex,len)  从startIndex开始截取len个(<b style="color:#dc4e41">改变原数组</b>)

    ```
    [1, 2, 3, 4, 5, 6, 7, 8].splice(2, 5) //'3,4,5,6,7'
    ```

17. unshift()  在数组头部插入参数(<b style="color:#dc4e41">改变原数组</b>)

    ```javascript
    [1, 2, 3, 4, 5].unshift(['a'])
    ```

18. fill(value,[start],[end]) ES6新增方法 scope:[start,end) value:填充数组元素的值(<b style="color:#dc4e41">改变原数组</b>)

    ```javascript
    [1, 2, 3, 4, 5, 6, 7, 8, 9].fill(0, 2, 5) //'1,2,0,0,0,6,7,8,9'
    ```



### 113、常用String方法

1. padStart(len, s) len: 当前字符串要填充到的目标长度 s: 填充到头部的字符串

   ```javascript
   'abc'.padStart(6, 'HA') //HAHabc
   ```

2. padEnd(len, s) len: 当前字符串要填充到的目标长度 s: 填充到尾部字符串

   ```javascript
   'zxc'.padEnd(6, 'HA') //zxcHAH
   ```

3. includes(str,[position]) 判断参数字符串是否包含在当前字符串内，返回Boolean。 str:要搜索的字符串  position:开始搜索子字符串的索引

   ```javascript
   'abcdefg'.includes('c', 2) //true
   ```

4. startsWith(str,[position]) 判断当前字符串是否以参数字符串开头，返回Boolean。  str:要搜索的字符串  position:开始搜索子字符串的索引

   ```javascript
   'www.baidu.com'.startsWith('.', 3) //true
   ```

5. endsWith(str,[position]) 判断当前字符串是否以参数字符串结尾，返回Boolean。  str:要搜索的字符串  position:开始搜索子字符串的索引

   ```javascript
   'www.baidu.com'.endsWith('u', 9) //true
   ```

6. repeat(count) 重复字符串  count:重复多少次原字符串

   ```javascript
   '6'.repeat(3) //'666'
   ```

7. valueOf()返回String对象原始值

   ```javascript
   '123abc#$%'.valueOf() //'123abc#$%'
   ```

8. trim()删除字符串两端空白字符

   ```javascript
   '   abc   '.trim() //'abc'
   ```

9. toUpperCase()将字符串转为大写形式并返回(不是字符串类型将被强制转换)

   ```javascript
   'hello'.toUpperCase() //'HELLO'
   ```

10. toLowerCase()将字符串转为大写形式并返回(不是字符串类型将被强制转换)

    ```javascript
    'HELLO'.toUpperCase() //'hello'
    ```

11. toString()返回对象字符串形式

    ```javascript
    new String('Hello').toString() //'Hello'
    ```

12. substring(indexStart[, indexEnd])返回从start索引到end索引的一个子集

    ```javascript
    "Mozilla".substring(0,3) //'Moz'
    ```

13. split()分割字符串

    ```javascript
    'a b c'.split(' ') //['a','b','c']
    ```

14. slice()返回一个新字符串

    ```javascript
    'abcde'.slice(2) //'cde'
    ```

15. search()执行正则表达式与String对象间的一个搜索匹配

    ```javascript
    'abcde123'.search(/\d/g) //5
    ```

16. replace()/replaceAll()返回一个新字符串，满足条件部分被替换

    ```javascript
    'abcde123'.replace('123','HHH') //'abcdeHHH'
    ```

17. match()/matchAll()返回一个字符串匹配正则表达式的结果

    ```javascript
    'AB123'.match(/[A-Z]/g) //['A','B']
    ```

18. indexOf/lastIndexOf返回String对象中第一次出现的指定值的索引，没有找到返回-1

    ```javascript
    'AB123'.indexOf('1') //2
    ```

19. concat()将多个字符串与原字符串连接合并，形成新字符串并返回

    ```javascript
    ''.concat(1,5) //'45'
    ```

20. charAt()返回指定字符

    ```javascript
    'AB123'.charAt(1) //'B'
    ```



### 114、Less、Scss

> Less:是一种动态样式语言. 对CSS赋予了动态语言的特性，如变量、继承、运算、函数。既可以在客户端上运行 (支持IE 6+, Webkit, Firefox)，也可在服务端运行

> Scss:是一种动态样式语言，Sass语法属于缩排语法。比css比多出好些功能(如变量、嵌套、运算,混入(Mixin)、继承、颜色处理，函数等)，更容易阅读

```
Sass与Scss是什么关系?
Sass的缩排语法，对于写惯css前端的web开发者来说很不直观，也不能将css代码加入到Sass里面，因此sass语法进行了改良，Sass 3就变成了Scss(sassy css)。与原来的语法兼容，只是用{}取代了原来的缩进。
```

**Less与Scss的共同之处：**

**1、混入(Mixins)**——class中的class

**2、参数混入**——可以传递参数的class，就像函数一样

**3、嵌套规则**——Class中嵌套class，从而减少重复的代码

**4、运算**——CSS中用数学运算 10px*10px=100px*

**5、颜色功能**——可以编辑颜色

**6、名字空间(namespace)**——分组样式，从而可以被调用

**7、作用域**——局部修改样式

**8、JavaScript 赋值**——在CSS中使用JavaScript表达式赋值



**Less与Scss区别:**

1. Less是基于JavaScript，是在客户端处理的
2. Scss是基于Ruby的，是在服务器端处理的(Ruby：开源的面向对象的服务器端脚本语言)
3. 关于变量在Less和Scss中的唯一区别就是Less用@，Scss用$。



### 115、async、await

>  **await 只在异步函数里面才起作用**。它可以放在任何异步里，基于 promise 的函数之前。它会暂停代码在该行上，直到 promise 完成，然后返回结果值。在暂停的同时，其他正在等待执行的代码就有机会执行了。

```javascript
      async function fn1(){
        console.log('1');
        await console.log('2');
        console.log('4');
      }
      fn1()
      console.log('3');
```

> 在wait上执行完就暂停，等主线程执行完，再接着执行异步



### 116、深度优先遍历、广度优先遍历

> 前序遍历、中序遍历、后序遍历：上左右、左中右、左右中

**深度优先遍历：**一条路径走到末结点，再回头走下一条路径（寻路），**主要解决连通性问题（寻路）**

**实现方法：**递归、压栈                                                                                                                                                                                                                                                                                                                       

**广度优先遍历：**从一个节点出发，遍历其相邻节点，再遍历下一层节点，**主要解决最短路径问题**

**实现方法：**队列

